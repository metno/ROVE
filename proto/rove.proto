syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

package rove;

service Rove {
  // TODO: should we reconsider allowing results to stream, in favour of a more
  // space efficient response format?
  rpc Validate (ValidateRequest) returns (stream ValidateResponse) {}
}

message GeoPoint {
  float lat = 1;
  float lon = 2;
}

message Polygon {
  repeated GeoPoint polygon = 1;
}

enum Flag { // WIP
  PASS = 0;
  FAIL = 1;
  WARN = 2;
  INCONCLUSIVE = 3;
  INVALID = 4;
  DATA_MISSING = 5;
  ISOLATED = 6;
}

message ValidateRequest {
  // name of the data source you want to QC data from
  string data_source = 1;
  // extra data sources providing data to help QC the first source, but the data
  // from these sources will not be QCed themselves
  repeated string backing_sources = 2;
  // timestamps defining an inclusive range of time to QC data from
  google.protobuf.Timestamp start_time = 3;
  google.protobuf.Timestamp end_time = 4;
  // an ISO 8601 duration stamp defining the time resolution of data do be QCed
  // (e.g. "PT1H" for hourly data)
  string time_resolution = 5;
  // one of 3 specifiers can be used to spatially specify down the data to be
  // QCed
  oneof SpaceSpec {
    // one series of data (i.e one data point per time step) with a string that
    // will be passed to the data connector to identify it. This will likely
    // represent something like a timeseries id, station id and param id pair,
    // or similar, but is left up to the data connector/source to define
    string one = 6;
    // a series of lat-lon points defining a polygon in space
    Polygon polygon = 7;
    // no spatial restriction at all
    google.protobuf.Empty all = 8;
  }
  // name of the pipeline of checks to be run on the data
  string pipeline = 9;
  // optional string containing extra information to be passed to the data
  // connector, to further specify the data to be QCed
  optional string extra_spec = 10;
}

message TestResult {
  google.protobuf.Timestamp time = 1;
  // data source defined identifier, it's recommended to use this to identify
  // a timeseries/station/location as appropriate
  string identifier = 2;
  Flag flag = 3;
}

message ValidateResponse {
  // name of the test this flag is from
  string test = 1;
  // results for each data point, paired with timestamp and an identifier to
  // identify the point
  repeated TestResult results = 2;
}
